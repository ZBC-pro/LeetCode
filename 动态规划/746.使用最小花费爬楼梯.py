'''
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

示例 1：
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

示例 2：
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。

人话：跳过花费大价格的台阶数，确保到最终的台阶代价不会很大

'''

class Solution:
    def minCostClimbingStairs(self, cost: list[int]) -> int:
        # 思路：动态规划，找到一条最低花费的路径，通过跳过代价较大的台阶，确保到达楼顶时的总花费最小。
        n = len(cost)
        dp = [0] * (n + 1)      # 记录每一次上台阶的最小代价。
        # 状态转移方程 到达第i个台阶的方式有两种
        # 从 i-1 台阶上跳一步上来，花费为dp[i-1] + cost[i-1]
        # 从 i-2 台阶上跳两步上来，花费为dp[i-2] + cost[i-2]
        # 转移方程 dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
        # 问题其实就是对每一步的两个选择做出一个较小代价的选择，依次累推，动态规划思想，解决最优问题。
        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])   # 一开始就可以用dp[i - 1]，是因为dp数组原本就是全为空，作和也不会影响什么
                                                                            # 并且

        return dp[n]



if __name__ == "__main__":
    s = Solution()
    cost = [1,100,10,2,1,100,1,70,10,1]
    print(s.minCostClimbingStairs(cost))
