'''
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

示例 1：
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

示例 2：
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。

人话：跳过花费大价格的台阶数，确保到最终的台阶代价不会很大

'''

class Solution:
    def minCostClimbingStairs(self, cost: list[int]) -> int:
        # 思路：动态规划，找到一条最低花费的路径，通过跳过代价较大的台阶，确保到达楼顶时的总花费最小。
        n = len(cost)
        dp = [0] * (n + 1)      # 记录每一次上台阶的最小代价。
        # 状态转移方程 到达第i个台阶的方式有两种
        # 从 i-1 台阶上跳一步上来，花费为dp[i-1] + cost[i-1]
        # 从 i-2 台阶上跳两步上来，花费为dp[i-2] + cost[i-2]
        # 转移方程 dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
        # 问题其实就是对每一步的两个选择做出一个较小代价的选择，依次累推，动态规划思想，解决最优问题。
        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
            print("\n")
            print(dp)

        return dp[n]

        '''
        我们每次要从第三个台阶开始算代价，
        拿cost = [100,1,10,2,3,15,1]为例：
        dp = [0, 0, 0, 0, 0, 0, 0, 0]
        第三个台阶（dp[2]）可以从第1个台阶跳两个（花费dp[0]+cost[0]到cost[2]）代价为0+100
                           也可以从第2个台阶跳一个（花费cost[1]到cost[2]）代价为100，dp[2]=1，第三个台阶最小花费为1
                           dp[0, 0, 1, 0, 0, 0, 0, 0]
        第四个台阶（dp[3]）可以从第2个台阶跳两个（花费cost[1]到cost[3]）代价为1
                           也可以从第3个台阶跳一个（花费dp[2]+cost[2]到cost[3],dp[3]=11,第四个台阶最小花费为1
                           dp[0, 0, 1, 1, 0, 0, 0, 0]
        第五个台阶（dp[4]）可以从第3个台阶跳两个（花费dp[2]+cost[2]到cost[4]）代价为1+10
                           也可以从第4个台阶跳一个（花费dp[3]+cost[3]到cost[3]），dp[4]=3,第五个台阶最小花费为3
                           dp[0, 0, 1, 1, 3, 0, 0, 0]
        第六个台阶（dp[5]）可以从第4个台阶跳两个（花费dp[3]+cost[3]到cost[4]）代价为1+2
                           也可以从第5个台阶跳一个（花费dp[4]+cost[4]到cost[3]），3+3，dp[4]=6,第六个台阶最小花费为3
                           dp[0, 0, 1, 1, 3, 3, 0, 0]  
        第七个台阶（dp[6]）可以从第5个台阶跳两个（花费dp[4]+cost[4]到cost[4]）代价为3+3
                           也可以从第6个台阶跳一个（花费dp[5]+cost[5]到cost[3]），6+15，dp[6]=6,第七个台阶最小花费为6
                           dp[0, 0, 1, 1, 3, 3, 6, 0]   
        第八个台阶（dp[7]）可以从第6个台阶跳两个（花费dp[5]+cost[5]到cost[4]）代价为3+15
                           也可以从第7个台阶跳一个（花费dp[6]+cost[6]到cost[3]），6+1，dp[7]=7,第八个台阶最小花费为7
                           dp[0, 0, 1, 1, 3, 3, 6, 7]            
        
        '''



if __name__ == "__main__":
    s = Solution()
    cost = [100,1,10,2,3,15,1]
    print(s.minCostClimbingStairs(cost))
