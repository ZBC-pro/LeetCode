'''
n 阶台阶,一次可以上一个，一次也可以上两个，到最上面共有多少种走法？
台阶数     多少种方法
0 个台阶   无意义
1 个台阶   1 种
2 个台阶   2 种
3 个台阶   3 种 因为 3 阶只和一阶和二阶台阶有关系，因为我们一步只能迈一阶或者两阶，到达三阶只能从 1 或者 2 迈上来的，不可能从 0 上来
4 个台阶   5 种 因为 4 阶只和二阶和三阶台阶有关系，因为我们一步只能迈一阶或者两阶，到达四阶只能从 2 或者 3 迈上来的，不可能从 0、1 上来
5 个台阶   8 种
当前阶数依赖于前两个状态

1. 确定dp数组含义和下标的含义
dp[i]： 达到 i 阶有dp[i]种方法

2. 确定递推公式
第 i 个是由第 i - 1 和第 i - 2 个推导出来
dp[i - 2]：达到 i - 2 阶有dp[i - 2]种方法，迈一步走两阶到dp[i]
dp[i - 1]：达到 i - 1 阶有dp[i - 1]种方法，迈一步走一阶到dp[i]
dp[i] = dp[i - 2] + dp[i - 1]

3. 初始化dp数组
最重要的是初始化前几位，因为后面都是前几位推导出来的
dp[0]可以为0也可以为1，题目中不用考虑这个，没有意义。
dp[1] = 1， dp[2] = 2

4. 遍历顺序
都是由前两个状态计算而来，如果是倒叙遍历，dp[i]都是固定数值，因为dp[i - 1]和dp[i - 2]没办法计算
从前向后

5. 打印dp数组

类fib数列
'''

class Solution(object):
    def climbStairs(self, n):
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        # 从第三阶开始用前两个状态去累加
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
            print(dp)

        return dp[n]



if __name__ == "__main__":
    n = int(input("请输入您的台阶数："))
    s = Solution()
    print(s.climbStairs(n))